"""
Visualization of histograms summarizing the distributions of
burst characteristics within a burst dictionary.

Visualization of a random subset of burst waveforms and their
average.

Visualization of the components generated by the dimensionality
reduction step.
"""

import numpy as np
import matplotlib.pyplot as plt
import imageio
import matplotlib.animation as animation

from os import makedirs
from os.path import join, exists
from scipy.ndimage import gaussian_filter1d

from help_funcs import confidence_ellipse


def plot_burst_characteristics(
    subject,
    burst_dictionary,
    tf_method,
    band,
    savepath,
    bprop=0.002,
    amplitude=True,
    screen_res=[1920, 972],
    dpi=300,
    savefigs=True,
    plot_format="pdf",
):
    """
    Figure depecting basic characteristics of a burst dictionary.

    Parameters
    ----------
    subject: int or list
             Integer or list of integers indicating the indices of
             subjects' data used for creating the burst dictionary.
    burst_dictionary: dict
                      Dictionary containing all detected bursts.
    tf_method: str {"wavelets", "superlets")
               String indicating the algorithm used for burst
               extraction. Ignored if 'savefigs' is set to "False".
    band: str {"mu", "beta"}
          Select band for burst detection.
    savepath: str
              Parent directory that contains all results. Ignored if
              'savefigs' is set to "False".
    bprop: float, optional
           Proportion of bursts to be plotted in first visualization.
           Defaults to 0.002.
    amplitude: bool, optional
               If "True" plot distribution of burst amplitude, else
               volume.
               Defaults to "True".
    screen_res: two-element list, optional
                Number of pixels for specifying the figure size in
                conjunction with "dpi".
                Defaults to [1920, 972].
    dpi: int, optional
         Number of dots per inch for specifying the figure size in
         conjunction with "screen_res".
         Defaults to 300.
    savefigs: bool, optional
              If set to "True" the visualizations are automatically
              saved. If set to "False" they are shown on screen.
              Defaults to "True".
    plot_format: str {"pdf", "png"}, optional
                 File format. Prefer "pdf" for editing with vector graphics
                 applications, or "png" for less space usage and better
                 integration with presentations.
                 Defaults to "pdf".
    """

    # Plotting hyperparameters.
    alphas = [0.5, 0.7]
    bins = [100, 31]
    colors = ["dodgerblue", "tab:orange", "crimson", "teal", "darkviolet"]
    cycles_thr = 5

    # Figure initialization.
    fig = plt.figure(constrained_layout=False, figsize=(7, 2.5), dpi=dpi)
    gs = fig.add_gridspec(
        nrows=1,
        ncols=2,
        wspace=0.25,
        right=0.98,
        left=0.08,
        top=0.95,
        bottom=0.15,
        width_ratios=[2, 3.0],
    )
    gs0 = gs[0].subgridspec(1, 1)
    gs1 = gs[1].subgridspec(1, 2, wspace=0.2)
    title_size = 8
    legend_size = 8
    legend_label_size = 6
    label_size = 8
    tick_size = 6
    a = 0.4
    linew = [0.5, 1.5]

    ax00 = fig.add_subplot(gs0[0])
    ax10 = fig.add_subplot(gs1[0])
    ax11 = fig.add_subplot(gs1[1])

    # Subplot 0: Waveforms.

    # Plotting hyperparameteres.
    perc_trials = bprop
    iqrs_lims = [0.05, 99.95]

    # Down-sample waveforms in order to plot.
    random_sample = np.random.randint(
        0,
        len(burst_dictionary["subject"]),
        size=int(perc_trials * len(burst_dictionary["subject"])),
    )

    ax00.plot(
        burst_dictionary["waveform_times"],
        burst_dictionary["waveform"][random_sample, :].T * 10e6,
        alpha=a,
        linewidth=linew[0],
    )
    ax00.plot(
        burst_dictionary["waveform_times"],
        np.mean(burst_dictionary["waveform"][random_sample], axis=0) * 10e6,
        "k",
        linewidth=linew[1],
        zorder=2,
    )
    ax00.margins(x=0)

    y_dist_0 = [
        np.percentile(burst_dictionary["waveform"] * 10e6, iqrs_lims[0]),
        np.percentile(burst_dictionary["waveform"] * 10e6, iqrs_lims[1]),
    ]

    ax00.set_ylim(y_dist_0[0], y_dist_0[1])

    ax00.set_xlabel("Time (s)", fontsize=label_size)
    ax00.set_ylabel("Amplitude (Î¼V)", fontsize=label_size)
    ax00.tick_params(axis="both", labelsize=tick_size)
    ax00.spines[["top", "right"]].set_visible(False)

    # Subplot 1: Amplitude and volume distributions.
    if amplitude == True:
        distr = burst_dictionary["peak_amp_iter"]
        xlabel = "log(Amplitude) (a.u)"
    else:
        distr = burst_dictionary["volume"]
        xlabel = "log(Volume) (a.u)"

    ids_s = np.where(burst_dictionary["fwhm_time"] * burst_dictionary["peak_freq"] < cycles_thr)[0]
    ids_x = np.where(burst_dictionary["fwhm_time"] * burst_dictionary["peak_freq"] >= cycles_thr)[0]

    ls = np.log10(distr[ids_s])
    lx = np.log10(distr[ids_x])

    ax10.hist(ls, bins[0], color=colors[1], alpha=alphas[0], label="< {}".format(cycles_thr))
    ax10.hist(lx, bins[0], color=colors[2], alpha=alphas[1], label=">= {}".format(cycles_thr))

    ax10.spines[["top", "right"]].set_visible(False)
    ax10.set_xlabel(xlabel, fontsize=label_size)
    ax10.set_ylabel("# Bursts", fontsize=label_size)
    ax10.tick_params(axis="both", labelsize=tick_size)
    ax10.legend(
        frameon=False,
        title="Number of cycles",
        title_fontsize=legend_size,
        fontsize=legend_label_size,
        alignment="left",
    )

    # Subplot 2: Frequency span and number of cycles distributions.
    perc = int(np.percentile(burst_dictionary["fwhm_freq"], 50))
    ids_s = np.where(burst_dictionary["fwhm_freq"] <= perc)[0]
    ids_x = np.where(burst_dictionary["fwhm_freq"] > perc)[0]

    ls = burst_dictionary["peak_freq"][ids_s]
    lx = burst_dictionary["peak_freq"][ids_x]

    ax11.hist(ls, bins[1], color=colors[3], alpha=alphas[0], label="<= {}".format(perc))
    ax11.hist(lx, bins[1], color=colors[4], alpha=alphas[1], label="> {}".format(perc))

    ax11.spines[["top", "right"]].set_visible(False)
    ax11.set_xlabel("Peak frequency (Hz)", fontsize=label_size)
    ax11.tick_params(axis="both", labelsize=tick_size)
    ax11.legend(
        frameon=False,
        title="Frequency span (Hz)",
        title_fontsize=legend_size,
        fontsize=legend_label_size,
        loc="upper right",
        alignment="left",
    )
    ax11.set_xlim(
        [
            np.min(burst_dictionary["peak_freq"]) - 1,
            np.max(burst_dictionary["peak_freq"]) + 1,
        ]
    )

    # Title.
    if len(np.unique(burst_dictionary["subject"])) == 1:
        subject = int(np.unique(burst_dictionary["subject"]))
        fig.suptitle(
            "{} burst dictionary of subject {}".format(band, subject),
            fontsize=title_size,
        )
        fig_name = join(
            savepath,
            "sub_{}/{}_burst_characteristics_{}.{}".format(
                subject, band, tf_method, plot_format
            ),
        )
    else:
        fig.suptitle(
            "Across-subjects {} burst dictionary".format(band), fontsize=title_size
        )
        fig_name = join(
            savepath,
            "across-subjects_{}_burst_characteristics_{}.{}".format(
                band, tf_method, plot_format
            ),
        )

    # Optional saving.
    if savefigs == True:
        fig.savefig(fig_name, dpi=dpi, facecolor="w", edgecolor="w")
    elif savefigs == False:
        plt.show()


def plot_burst_chars_conditioned(
    subject,
    burst_dictionary,
    exp_time_periods,
    channel_ids,
    tf_method,
    band,
    savepath,
    subsets="all",
    screen_res=[1920, 972],
    dpi=300,
    savefigs=True,
    plot_format="pdf",
):
    """
    Figure depecting basic characteristics of a burst dictionary.

    Parameters
    ----------
    subject: int or list
             Integer or list of integers indicating the indices of
             subjects' data used for creating the burst dictionary.
    burst_dictionary: dict
                      Dictionary containing all detected bursts.
    exp_time_periods: 4-element list or 1D array
                      Beginning of baseline period, beginning of task period,
                      end of task period, and end of rebound period (in seconds
                      relative to the time-locked event).
    channel_ids: list or str
                 Indices of channels to take into account during burst
                 dictionary creation.
    tf_method: str {"wavelets", "superlets")
               String indicating the algorithm used for burst
               extraction. Ignored if 'savefigs' is set to "False".
    band: str {"mu", "beta"}
          Select band for burst detection.
    savepath: str
              Parent directory that contains all results. Ignored if
              'savefigs' is set to "False".
    subsets: str {"all", "short", "long"}, optional
             Str that controls which subset of bursts to be plotted with
             respect to the number of cycles.
             Defaults to "all".
    screen_res: two-element list, optional
                Number of pixels for specifying the figure size in
                conjunction with "dpi".
                Defaults to [1920, 972].
    dpi: int, optional
         Number of dots per inch for specifying the figure size in
         conjunction with "screen_res".
         Defaults to 300.
    savefigs: bool, optional
              If set to "True" the visualizations are automatically
              saved. If set to "False" they are shown on screen.
              Defaults to "True".
    plot_format: str {"pdf", "png"}, optional
                 File format. Prefer "pdf" for editing with vector graphics
                 applications, or "png" for less space usage and better
                 integration with presentations.
                 Defaults to "pdf".
    """

    # Plotting hyperparameters.
    alphas = [0.5, 0.7, 0.5]
    bins = [[20, 20], [20, 20], [20, 20]]
    colors = ["dodgerblue", "tab:orange"]
    cycles_thr = 10
    

    # Figure initialization.
    fig = plt.figure(constrained_layout=True, figsize=(7, 4.5), dpi=dpi)
    title_size = 8
    legend_size = 6
    legend_label_size = 4
    label_size = 8
    tick_size = 6

    (fig0, fig1, fig2) = fig.subfigures(1, 3, wspace=0.05, width_ratios=[1.3, 1, 1])
    gs0 = fig0.add_gridspec(2, 2)
    gs1 = fig1.add_gridspec(2, 2)
    gs2 = fig2.add_gridspec(2, 2)

    ax000 = fig0.add_subplot(gs0[0, 0])
    ax001 = fig0.add_subplot(gs0[0, 1])
    ax010 = fig0.add_subplot(gs0[1, 0])
    ax011 = fig0.add_subplot(gs0[1, 1])
    axes0 = [ax000, ax001, ax010, ax011]

    ax100 = fig1.add_subplot(gs1[0, 0])
    ax101 = fig1.add_subplot(gs1[0, 1])
    ax110 = fig1.add_subplot(gs1[1, 0])
    ax111 = fig1.add_subplot(gs1[1, 1])
    axes1 = [ax100, ax101, ax110, ax111]

    ax200 = fig2.add_subplot(gs2[0, 0])
    ax201 = fig2.add_subplot(gs2[0, 1])
    ax210 = fig2.add_subplot(gs2[1, 0])
    ax211 = fig2.add_subplot(gs2[1, 1])
    axes2 = [ax200, ax201, ax210, ax211]

    x_lims = []
    y_lims = []

    # Channel and condition specific bursts.
    labels = np.unique(burst_dictionary["label"])

    c3l = (burst_dictionary["channel"] == channel_ids[0]) & (
        burst_dictionary["label"] == labels[0]
    )

    c3r = (burst_dictionary["channel"] == channel_ids[0]) & (
        burst_dictionary["label"] == labels[1]
    )

    c4l = (burst_dictionary["channel"] == channel_ids[1]) & (
        burst_dictionary["label"] == labels[0]
    )

    c4r = (burst_dictionary["channel"] == channel_ids[1]) & (
        burst_dictionary["label"] == labels[1]
    )

    # Pre-task bursts.
    pre = burst_dictionary["peak_time"] < exp_time_periods[1]

    # Bursts during task duarion.
    during = (burst_dictionary["peak_time"] >= exp_time_periods[1]) & (
        burst_dictionary["peak_time"] <= exp_time_periods[2]
    )

    # Post-task bursts.
    post = burst_dictionary["peak_time"] > exp_time_periods[2]

    # Amplitude distributions.
    for i, tb in enumerate([pre, during, post]):
        # Combination of conditions.
        conds = [(c3l & tb), (c3r & tb), (c4l & tb), (c4r & tb)]

        if i == 0:
            axes = axes0
            secs = np.around(np.abs(exp_time_periods[1] - exp_time_periods[0]), 2)
        elif i == 1:
            axes = axes1
            secs = np.around(np.abs(exp_time_periods[2] - exp_time_periods[1]), 2)
        elif i == 2:
            axes = axes2
            secs = np.around(np.abs(exp_time_periods[3] - exp_time_periods[2]), 2)

        for j, cond in enumerate(conds):
            # Number of cycles.
            ids_s = np.where((burst_dictionary["fwhm_time"] * burst_dictionary["peak_freq"] < cycles_thr) & cond)[0]
            ids_x = np.where((burst_dictionary["fwhm_time"] * burst_dictionary["peak_freq"] >= cycles_thr) & cond)[0]

            ls, bs = np.histogram(
                np.log10(burst_dictionary["peak_amp_iter"][ids_s]), bins=bins[i][0]
            )
            lx, bx = np.histogram(
                np.log10(burst_dictionary["peak_amp_iter"][ids_x]), bins=bins[i][1]
            )
            ls = ls / (secs * len(np.unique(burst_dictionary["trial"][np.array(cond)])))
            lx = lx / (secs * len(np.unique(burst_dictionary["trial"][np.array(cond)])))

            # Provide labels once.
            if i == 2 and j == 1:
                if subsets == "all":
                    axes[j].stairs(
                        ls, bs, color=colors[0], alpha=alphas[0], fill=True, label="< {}".format(cycles_thr)
                    )
                    axes[j].stairs(
                        lx,
                        bx,
                        color=colors[1],
                        alpha=alphas[1],
                        fill=True,
                        label=">= 1",
                    )
                elif subsets == "short":
                    axes[j].stairs(
                        ls, bs, color=colors[0], alpha=alphas[0], fill=True, label="< {}".format(cycles_thr)
                    )
                elif subsets == "long":
                    axes[j].stairs(
                        lx,
                        bx,
                        color=colors[1],
                        alpha=alphas[1],
                        fill=True,
                        label=">= 1",
                    )
            else:
                if subsets == "all":
                    axes[j].stairs(ls, bs, color=colors[0], alpha=alphas[0], fill=True)
                    axes[j].stairs(lx, bx, color=colors[1], alpha=alphas[1], fill=True)
                elif subsets == "short":
                    axes[j].stairs(ls, bs, color=colors[0], alpha=alphas[0], fill=True)
                elif subsets == "long":
                    axes[j].stairs(lx, bx, color=colors[1], alpha=alphas[1], fill=True)

            x_lims.append(axes[j].get_xlim())
            y_lims.append(axes[j].get_ylim())

            # Adjust axes labels.
            axes[j].spines[["top", "right"]].set_visible(False)
            if i == 0 and j == 0:
                axes[j].set_ylabel(
                    "C3\n\nAverage burst rate per trial",
                    fontsize=label_size,
                    rotation=90,
                )
            elif i == 0 and j == 2:
                axes[j].set_ylabel(
                    "C4\n\nAverage burst rate per trial",
                    fontsize=label_size,
                    rotation=90,
                )
            if j == 2:
                axes[j].set_xlabel("log(Amplitude) (a.u)", fontsize=label_size)

            # Adjust axes titles and ticklabels.
            if j == 0:
                axes[j].set_title("Left hand", fontsize=title_size)
            elif j == 1:
                axes[j].set_title("Right hand", fontsize=title_size)

            if i == 0 and (j == 0 or j == 2):
                axes[j].tick_params(axis="y", labelsize=tick_size)
            else:
                axes[j].set_yticklabels([])

            if j < 2:
                axes[j].set_xticklabels([])
            else:
                axes[j].tick_params(axis="x", labelsize=tick_size)

            # Legend.
            if i == 2 and j == 1:
                axes[j].legend(
                    frameon=False,
                    title="Duration (s)",
                    title_fontsize=legend_size,
                    fontsize=legend_label_size,
                    alignment="left",
                )

    # Adjust axes limits.
    if np.min(x_lims) < -7.0:
        x_min = np.min(x_lims)
    else:
        x_min = -7.0
    if np.min(x_lims) > -5.0:
        x_max = np.max(x_lims)
    else:
        x_max = -5.0
    y_min = np.min(y_lims)
    y_max = np.max(y_lims)

    for i, _ in enumerate([pre, during, post]):
        if i == 0:
            axes = axes0
        elif i == 1:
            axes = axes1
        elif i == 2:
            axes = axes2

        for j, _ in enumerate(conds):
            axes[j].set_xlim(x_min, x_max)
            axes[j].set_ylim(y_min, y_max)

    # Subfigures' titles.
    fig0.suptitle("Baseline period", fontsize=title_size)
    fig1.suptitle("Task period", fontsize=title_size)
    fig2.suptitle("Rebound period", fontsize=title_size)

    # Title.
    if len(np.unique(burst_dictionary["subject"])) == 1:
        subject = int(np.unique(burst_dictionary["subject"]))
        fig.suptitle(
            "{} burst characteristics per task period, condition and channel of subject {}".format(
                band, subject
            ),
            fontsize=title_size,
        )
        fig_name = join(
            savepath,
            "sub_{}/burst_characteristics_{}_{}_conditioned.{}".format(
                subject, band, tf_method, plot_format
            ),
        )
    else:
        fig.suptitle(
            "Across-subjects {} burst characteristics per task period, condition and channel".format(
                band
            ),
            fontsize=title_size,
        )
        fig_name = join(
            savepath,
            "across-subjects_burst_characteristics_{}_{}_conditioned.{}".format(
                band, tf_method, plot_format
            ),
        )

    # Optional saving.
    if savefigs == True:
        fig.savefig(fig_name, dpi=dpi, facecolor="w", edgecolor="w")
    elif savefigs == False:
        plt.show()


def plot_drm_waveforms(
    burst_dictionary,
    drm,
    drm_comps,
    channel_ids,
    solver,
    binned_plot_time,
    base_time_lims,
    mi_end,
    tf_method,
    band,
    savepath,
    comps_to_analyze=8,
    screen_res=[1920, 972],
    dpi=300,
    savefigs=True,
    plot_format="pdf",
):
    """
    Figure depecting the explained variance of each principal component axis,
    the modulation of the score along each axis within the epxrerimental trial
    time, as well as the component's shape and how they influence the shape of
    the average burst shape.

    Parameters
    ----------
    burst_dictionary: dict
                      Dictionary containing all detected bursts.
    drm: scikit-learn or MNE-python model
         Model returned from the corresponding sklearn, or
         MNE-python function.
    drm_comps: numpy array
               Array containing the transformed bursts as
               returned by the 'fit_transform' method of 'drm'.
    channel_ids: list or str
                 Indices of channels to take into account during burst
                 dictionary creation.
    solver: str, {"pca", "csp"}
            Dimensionality reduction algorithm. Implements the sklearn
            PCA or the MNE-python CSP model.
    binned_plot_time: numpy array
                      Array representing the trimmed experimental time
                      with wide time steps, needed for an estimation
                      of burst rate in non-overlapping windows.
    base_time_lims: two-element list or 1D array
                    Start and end time of the baseline period in seconds,
                    relative to the time-locked event.
    mi_end: int
            End time of the task period in seconds, relative to the
            time-locked event.
    tf_method: str {"wavelets", "superlets"}
               String indicating the algorithm used for burst
               extraction. Ignored if 'savefigs' is set to "False".
    band: str {"mu", "beta"}
          Selected band for burst detection.
    savepath: str
              Parent directory that contains all results. Ignored if
              'savefigs' is set to "False".
    comps_to_analyze: int, optional
                    Number of principal components used while plotting.
                    Defaults to 8.
    screen_res: two-element list, optional
                Number of pixels for specifying the figure size in
                conjunction with "dpi".
                Defaults to [1920, 972].
    dpi: int, optional
         Number of dots per inch for specifying the figure size in
         conjunction with "screen_res".
         Defaults to 300.
    savefigs: bool, optional
              If set to "True" the visualizations are automatically
              saved. If set to "False" they are shown on screen.
              Defaults to "True".
    plot_format: str {"pdf", "png"}, optional
                 File format. Prefer "pdf" for editing with vector graphics
                 applications, or "png" for less space usage and better
                 integration with presentations.
                 Defaults to "pdf".
    """

    # Colormap for components axes.
    palette = [
        "limegreen",
        "mediumblue",
        "darkorange",
        "deeppink",
        "darkviolet",
        "firebrick",
        "olivedrab",
        "slateblue",
    ]

    # Experimental time trimming for edge effect removal.
    binned_plot_time = binned_plot_time[3:-4]

    # Different figure layout based on 'solver'.
    if solver == "pca":
        # Figure initilization.
        fig = plt.figure(constrained_layout=True, figsize=(7, 9), dpi=dpi)
        title_size = 8
        label_size = 8
        tick_size = 6
        linew = [0.5, 0.75, 1.25]

        if comps_to_analyze <= 8:
            rows = 1
            cols = 8
        elif comps_to_analyze > 8 and comps_to_analyze <= 12:
            rows = 2
            cols = 6
        elif comps_to_analyze > 12:
            rows = 3
            cols = 6

        gs = fig.add_gridspec(
            nrows=3,
            ncols=1,
            hspace=1.0,
            right=0.90,
            left=0.15,
            top=0.95,
            bottom=0.15,
            height_ratios=[1.5, 1 * rows, 2.5],
        )
        gs0 = gs[0].subgridspec(1, 1)
        gs1 = gs[1].subgridspec(rows, cols, wspace=0.10)
        gs2 = gs[2].subgridspec(2, 2, hspace=0.05, wspace=0.07)

        axes00 = fig.add_subplot(gs0[0])
        cv = axes00.twinx()

        axes200 = fig.add_subplot(gs2[0, 0])
        axes201 = fig.add_subplot(gs2[0, 1])
        axes210 = fig.add_subplot(gs2[1, 0])
        axes211 = fig.add_subplot(gs2[1, 1])

        # Subplot 1: Bar plot of explained variance.
        if drm_comps.shape[1] >= 20:
            comps = np.arange(1, 20 + 1, 1)
        else:
            comps = np.arange(1, drm_comps.shape[1] + 1, 1)
        barlist = axes00.bar(comps, drm.explained_variance_ratio_[: len(comps)] * 100)
        barplotcolors = palette + ["gold"] * (len(barlist) - len(palette))
        for b in range(len(barlist)):
            barlist[b].set_color(barplotcolors[b])

        axes00.set_xlabel("Motifs", fontsize=label_size)
        axes00.set_ylabel("Explained variance (%)", fontsize=label_size)
        axes00.set_xticks(comps)
        axes00.tick_params(axis="both", labelsize=tick_size)
        axes00.spines[["top", "right"]].set_visible(False)

        cv.plot(
            range(1, len(comps) + 1),
            drm.explained_variance_ratio_[: len(comps)].cumsum() * 100,
            "k",
        )
        cv.set_ylabel("Cumulative exaplined\nvariance (%)", fontsize=label_size)
        cv.tick_params(axis="both", labelsize=tick_size)
        cv.spines[["top"]].set_visible(False)
        axes00.set_title(
            "Explained variance of burst waveforms per motif", fontsize=title_size
        )

        # Subplot 2: Components' motifs.
        components = drm.components_
        lift = 3

        # Colormap for discretized PCA space.
        colors = plt.cm.cool(np.linspace(0, 1, 20))
        m = np.mean(burst_dictionary["waveform"], axis=0)
        m = m / np.max(m)

        y_lims = np.empty([2, rows, cols])
        gen_ax = []

        for i in range(comps_to_analyze):
            # Take each component separately.
            ax = fig.add_subplot(gs1[i // cols, i % cols])
            gen_ax.append(ax)
            comps = np.linspace(-5, 5, 20)
            for idx, p in enumerate(comps):
                # Plot each deviation from the mean.
                val = m + p * components[i, :]
                ax.plot(
                    burst_dictionary["waveform_times"],
                    val,
                    color=colors[idx],
                    zorder=1,
                    linewidth=linew[0],
                )

            vec = components[i, :]
            ax.plot(
                burst_dictionary["waveform_times"],
                m,
                c="k",
                linewidth=linew[2],
                zorder=2,
            )
            ax.plot(
                burst_dictionary["waveform_times"],
                vec + lift,
                c=barplotcolors[i],
                linewidth=linew[2],
                zorder=3,
            )

            y_lims[:, i // cols, i % cols] = ax.get_ylim()

        # Same limits.
        y_lims = [np.nanmin(y_lims[0, :]), np.nanmax(y_lims[1, :])]
        y_lim = np.max(np.abs(y_lims))
        y_lims = [-y_lim, y_lim]

        for i in range(comps_to_analyze):
            ax = gen_ax[i]
            ax.set_ylim(y_lims)
            if i % cols != 0:
                ax.set_yticks([])
                ax.set_yticklabels([])

            if i // cols != rows - 1:
                ax.set_xticks([])
                ax.set_xticklabels([])
            ax.tick_params(axis="both", labelsize=tick_size)
            ax.set_title("Motif {}".format((i + 1)), fontsize=title_size)

            if rows == 1:
                if i == 3:
                    ax.set_xlabel("Time (s)", fontsize=label_size)
                if i == 0:
                    ax.set_ylabel("Score (a.u.)", fontsize=label_size)
            else:
                if i == cols + int(cols / 2):
                    ax.set_xlabel("Time (s)", fontsize=label_size)
                if i == cols:
                    ax.set_ylabel("Score (a.u.)", fontsize=label_size)

        # Subplot 3: Components' score modulation during experimental time.

        # Channel and condition specific bursts.
        labels = np.unique(burst_dictionary["label"])
        fig2_labels = [
            "C3, left hand",
            "C3, right hand",
            "C4, left hand",
            "C4, right hand",
        ]

        c3l = (burst_dictionary["channel"] == channel_ids[0]) & (
            burst_dictionary["label"] == labels[0]
        )

        c3r = (burst_dictionary["channel"] == channel_ids[0]) & (
            burst_dictionary["label"] == labels[1]
        )

        c4l = (burst_dictionary["channel"] == channel_ids[1]) & (
            burst_dictionary["label"] == labels[0]
        )

        c4r = (burst_dictionary["channel"] == channel_ids[1]) & (
            burst_dictionary["label"] == labels[1]
        )

        for p in range(comps_to_analyze):
            # Take each component separately.
            metric = drm_comps[:, p]

            # Take each hand and channel separately.
            for l, (cs, ax) in enumerate(
                zip([c3l, c3r, c4l, c4r], [axes200, axes201, axes210, axes211])
            ):
                mean_measure = []
                stderr_measure = []
                for t_idx in range(len(binned_plot_time) - 1):
                    # Find the bursts occuring in each time window.
                    t_bursts = (
                        (burst_dictionary["peak_time"] >= binned_plot_time[t_idx])
                        & (burst_dictionary["peak_time"] < binned_plot_time[t_idx + 1])
                        & cs
                    )

                    mean_measure.append(
                        np.mean(metric[t_bursts]) if any(t_bursts) else 0
                    )
                    stderr_measure.append(
                        np.std(metric[t_bursts]) / np.sqrt(len(t_bursts))
                        if any(t_bursts)
                        else 0
                    )

                # Apply 2-windows smoothing.
                mean_measure = gaussian_filter1d(np.array(mean_measure), 2)
                stderr_measure = gaussian_filter1d(np.array(stderr_measure), 2)

                ax.plot(
                    binned_plot_time[:-1],
                    mean_measure,
                    color=barplotcolors[p],
                    label="PC {}".format((p + 1)),
                    linewidth=linew[1],
                )

                ax.fill_between(
                    binned_plot_time[:-1],
                    mean_measure - stderr_measure,
                    mean_measure + stderr_measure,
                    alpha=0.2,
                    color=barplotcolors[p],
                )

        for k, (ax, fl) in enumerate(
            zip([axes200, axes201, axes210, axes211], fig2_labels)
        ):
            # Baseline.
            ax.axvline(mi_end, color="tab:gray", linestyle="--", linewidth=linew[1])
            ax.axvline(
                base_time_lims[1], color="tab:gray", linestyle="--", linewidth=linew[1]
            )
            ax.plot(
                [binned_plot_time[:-1][0], binned_plot_time[:-1][-1]],
                [0, 0],
                "k--",
                linewidth=linew[1],
            )

            # Limits.
            ax.set_ylim(
                [
                    np.min(
                        [
                            axes200.get_ylim(),
                            axes201.get_ylim(),
                            axes210.get_ylim(),
                            axes211.get_ylim(),
                        ]
                    ),
                    np.max(
                        [
                            axes200.get_ylim(),
                            axes201.get_ylim(),
                            axes210.get_ylim(),
                            axes211.get_ylim(),
                        ]
                    ),
                ]
            )

            # Spines and labels.
            ax.spines[["top", "right"]].set_visible(False)
            if k >= 2:
                ax.set_xlabel("Time (s)", fontsize=label_size)
            if k == 0 or k == 2:
                ax.set_ylabel("Score (a.u.)", fontsize=label_size)
            ax.tick_params(axis="both", labelsize=tick_size)
            ax.set_title(fl, fontsize=title_size)

    elif solver == "csp":
        # Figure initilization.
        fig = plt.figure(constrained_layout=True, figsize=(7, 4.5), dpi=dpi)
        (fig0, fig1, fig2) = fig.subfigures(
            1, 3, wspace=0.05, width_ratios=[0.4, 0.3, 0.3]
        )
        gs0 = fig0.add_gridspec(3, 1, hspace=0.10, height_ratios=[1, 1, 1])
        title_size = 8
        label_size = 8
        tick_size = 6
        linew = [0.5, 0.75, 1.25]

        cols = 2
        if comps_to_analyze <= 4:
            rows = 2
        elif comps_to_analyze > 4 and comps_to_analyze <= 6:
            rows = 3
        elif comps_to_analyze > 6:
            rows = 4
        axes1 = fig1.subplots(rows, cols)
        axes2 = fig2.subplots(rows, cols)

        # Subplot 1: Components' score modulation during experimental time.
        axes00 = fig0.add_subplot(gs0[1])

        for p in range(comps_to_analyze):
            # Take each component separately.
            metric = drm_comps[:, p]

            mean_measure = []
            stderr_measure = []
            for t_idx in range(len(binned_plot_time) - 1):
                # Find the bursts occuring in each time window.
                t_bursts = np.where(
                    np.logical_and(
                        burst_dictionary["peak_time"] >= binned_plot_time[t_idx],
                        burst_dictionary["peak_time"] < binned_plot_time[t_idx + 1],
                    )
                )[0]
                mean_measure.append(np.mean(metric[t_bursts]) if any(t_bursts) else 0)
                stderr_measure.append(
                    np.std(metric[t_bursts]) / np.sqrt(len(t_bursts))
                    if any(t_bursts)
                    else 0
                )

            mean_measure = np.array(mean_measure)
            stderr_measure = np.array(stderr_measure)

            axes00.plot(
                binned_plot_time[:-1],
                mean_measure,
                color=palette[p],
                label="PC {}".format((p + 1)),
                linewidth=linew[1],
            )
            axes00.fill_between(
                binned_plot_time[:-1],
                mean_measure - stderr_measure,
                mean_measure + stderr_measure,
                alpha=0.2,
                color=palette[p],
            )

        # Baseline.
        axes00.axvline(mi_end, color="tab:gray", linestyle="--", linewidth=linew[1])
        axes00.axvline(
            base_time_lims[0], color="tab:gray", linestyle="--", linewidth=linew[1]
        )
        axes00.axvline(
            base_time_lims[1], color="tab:gray", linestyle="--", linewidth=linew[1]
        )
        axes00.plot(
            [binned_plot_time[:-1][0], binned_plot_time[:-1][-1]],
            [0, 0],
            "k--",
            linewidth=linew[1],
        )

        axes00.set_xlabel("Time (s)", fontsize=label_size)
        axes00.set_ylabel("Score (a.u.)", fontsize=label_size)
        axes00.tick_params(axis="both", labelsize=tick_size)
        axes00.set_title("Average score modulation per motif", fontsize=title_size)

        # Subplots 2 & 3: CSP filters and patterns.
        components = [
            drm.filters_.T[: 2 * rows : 2, :],
            np.flip(drm.filters_.T[1 : 2 * rows + 1 : 2, :], axis=0),
        ]
        patterns = [
            drm.patterns_.T[: 2 * rows : 2, :],
            np.flip(drm.patterns_.T[1 : 2 * rows + 1 : 2, :], axis=0),
        ]

        lift = 25

        y_lims1 = np.empty([2, rows, cols])
        y_lims2 = np.empty([2, rows, cols])

        # Colormap for discretized PCA space.
        colors = plt.cm.cool(np.linspace(0, 1, 20))
        m = np.mean(burst_dictionary["waveform"], axis=0)
        m = m / np.max(m)

        for i in range(len(components[0])):
            # Take each component separately.
            ax10 = axes1[i, 0]
            ax11 = axes1[i, 1]
            ax20 = axes2[i, 0]
            ax21 = axes2[i, 1]

            comps = np.linspace(-5, 5, 20)
            for idx, p in enumerate(comps):
                # Plot each deviation from the mean.
                val0 = m + p * components[0][i, :]
                val1 = m + p * components[1][i, :]

                ax10.plot(
                    burst_dictionary["waveform_times"],
                    val0,
                    color=colors[idx],
                    linewidth=linew[0],
                    zorder=1,
                )
                ax11.plot(
                    burst_dictionary["waveform_times"],
                    val1,
                    color=colors[idx],
                    linewidth=linew[0],
                    zorder=1,
                )

            ax10.plot(
                burst_dictionary["waveform_times"],
                m,
                c="k",
                linewidth=linew[2],
                zorder=2,
            )
            ax11.plot(
                burst_dictionary["waveform_times"],
                m,
                c="k",
                linewidth=linew[2],
                zorder=2,
            )

            ax10.plot(
                burst_dictionary["waveform_times"],
                components[0][i, :] + lift,
                c=palette[i],
                linewidth=linew[2],
                zorder=3,
            )
            ax11.plot(
                burst_dictionary["waveform_times"],
                components[1][i, :] + lift,
                c=palette[i + rows],
                linewidth=linew[2],
                zorder=3,
            )
            ax20.plot(
                burst_dictionary["waveform_times"],
                patterns[0][i, :],
                c=palette[i],
                linewidth=linew[2],
                zorder=3,
            )
            ax21.plot(
                burst_dictionary["waveform_times"],
                patterns[1][i, :],
                c=palette[i + rows],
                linewidth=linew[2],
                zorder=3,
            )

            y_lims1[:, i, 0] = ax10.get_ylim()
            y_lims1[:, i, 1] = ax11.get_ylim()
            y_lims2[:, i, 0] = ax20.get_ylim()
            y_lims2[:, i, 1] = ax21.get_ylim()

        # Same limits.
        y_lims1 = [np.nanmin(y_lims1[0, :, :]), np.nanmax(y_lims1[1, :, :])]
        y_lim1 = np.max(np.abs(y_lims1))
        y_lims1 = [-y_lim1, y_lim1]

        y_lims2 = [np.nanmin(y_lims2[0, :, :]), np.nanmax(y_lims2[1, :, :])]
        y_lim2 = np.max(np.abs(y_lims2))
        y_lims2 = [-y_lim2, y_lim2]

        for i in range(len(components[0])):
            ax10 = axes1[i, 0]
            ax11 = axes1[i, 1]
            ax20 = axes2[i, 0]
            ax21 = axes2[i, 1]

            ax10.set_ylim(y_lims1)
            ax11.set_ylim(y_lims1)
            ax20.set_ylim(y_lims2)
            ax21.set_ylim(y_lims2)

            ax11.set_yticks([])
            ax11.set_yticklabels([])
            ax21.set_yticks([])
            ax21.set_yticklabels([])

            if i != rows - 1:
                ax10.set_xticks([])
                ax11.set_xticks([])
                ax10.set_xticklabels([])
                ax11.set_xticklabels([])

                ax20.set_xticks([])
                ax21.set_xticks([])
                ax20.set_xticklabels([])
                ax21.set_xticklabels([])

            ax10.tick_params(axis="both", labelsize=tick_size)
            ax10.set_title("{}".format((i + 1)), fontsize=title_size)
            ax11.tick_params(axis="both", labelsize=tick_size)
            ax11.set_title("{}".format((2 * rows - i)), fontsize=title_size)

            ax20.tick_params(axis="both", labelsize=tick_size)
            ax20.set_title("{}".format((i + 1)), fontsize=title_size)
            ax21.tick_params(axis="both", labelsize=tick_size)
            ax21.set_title("{}".format((2 * rows - i)), fontsize=title_size)

        fig1.supxlabel("Time (s)", fontsize=label_size)
        fig1.supylabel("Score (a.u.)", fontsize=label_size)
        fig1.suptitle("Filters", fontsize=title_size)

        fig2.supxlabel("Time (s)", fontsize=label_size)
        fig2.suptitle("Patterns", fontsize=title_size)

    # Title.
    if len(np.unique(burst_dictionary["subject"])) == 1:
        subject = int(np.unique(burst_dictionary["subject"]))
        fig.suptitle(
            "Subject {}-specific {} motifs".format(subject, band), fontsize=title_size
        )
        figname = join(
            savepath,
            "sub_{}/{}_motifs_{}_{}.{}".format(
                subject, band, solver, tf_method, plot_format
            ),
        )
    else:
        fig.suptitle("Across-subjects {} motifs".format(band), fontsize=title_size)
        figname = join(
            savepath,
            "across-subjects_{}_motifs_{}_{}.{}".format(
                band, solver, tf_method, plot_format
            ),
        )

    # Optional saving.
    if savefigs == True:
        fig.savefig(figname, dpi=dpi, facecolor="w", edgecolor="w")
    elif savefigs == False:
        plt.show()


def plot_score_modulation(
    burst_dictionary,
    drm_comps,
    channel_ids,
    solver,
    binned_plot_time,
    base_time_lims,
    mi_end,
    tf_method,
    savepath,
    comps_to_visualize=[2, 3, 4],
    screen_res=[1920, 972],
    dpi=300,
    savefigs=True,
    plot_format="pdf",
):
    """
    3 dimensional visualization of average score modulation over time,
    for specific components.

    Parameters
    ----------
    burst_dictionary: dict
                      Dictionary containing all detected bursts.
    drm_comps: numpy array
               Array containing the transformed bursts as
               returned by the 'fit_transform' method of 'drm'.
    channel_ids: list or str
                 Indices of channels to take into account during burst
                 dictionary creation.
    solver: str, {"pca", "csp"}
            Dimensionality reduction algorithm. Implements the sklearn
            PCA or the MNE-python CSP model.
    binned_plot_time: numpy array
                      Array representing the trimmed experimental time
                      with wide time steps, needed for an estimation
                      of burst rate in non-overlapping windows.
    base_time_lims: two-element list or 1D array
                    Start and end time of the baseline period in seconds,
                    relative to the time-locked event.
    mi_end: int
            End time of the task period in seconds, relative to the
            time-locked event.
    tf_method: str {"wavelets", "superlets"}
               String indicating the algorithm used for burst
               extraction. Ignored if 'savefigs' is set to "False".
    savepath: str
              Parent directory that contains all results. Ignored if
              'savefigs' is set to "False".
    comps_to_visualize: list, optional
                        List of components used for plotting.
                        Defaults to [2,3,4].
    screen_res: two-element list, optional
                Number of pixels for specifying the figure size in
                conjunction with "dpi".
                Defaults to [1920, 972].
    dpi: int, optional
         Number of dots per inch for specifying the figure size in
         conjunction with "screen_res".
         Defaults to 300.
    savefigs: bool, optional
              If set to "True" the visualizations are automatically
              saved. If set to "False" they are shown on screen.
              Defaults to "True".
    plot_format: str {"pdf", "png"}, optional
                 File format. Prefer "pdf" for editing with vector graphics
                 applications, or "png" for less space usage and better
                 integration with presentations.
                 Defaults to "pdf".
    """

    # Number of components.
    n_comps = len(comps_to_visualize)
    if n_comps < 2 or n_comps > 3:
        raise ValueError("Number of components for plotting should be 2 or 3.")

    # Figure initialization.
    fig = plt.figure(constrained_layout=True, figsize=(7, 3), dpi=dpi)
    gs = fig.add_gridspec(1, 1)
    gs0 = gs[0].subgridspec(1, 1)
    ax = fig.add_subplot(gs0[0], projection="3d")

    linew = 1.5
    label_size = 6
    tick_size = 6
    legend_size = 6
    legend_label_size = 5

    fig_labels = ["C3, left hand", "C3, right hand", "C4, left hand", "C4, right hand"]

    fig_colors = ["firebrick", "royalblue", "darkorange", "darkorchid"]

    # Channel and condition specific bursts.
    labels = np.unique(burst_dictionary["label"])

    c3l = (burst_dictionary["channel"] == channel_ids[0]) & (
        burst_dictionary["label"] == labels[0]
    )

    c3r = (burst_dictionary["channel"] == channel_ids[0]) & (
        burst_dictionary["label"] == labels[1]
    )

    c4l = (burst_dictionary["channel"] == channel_ids[1]) & (
        burst_dictionary["label"] == labels[0]
    )

    c4r = (burst_dictionary["channel"] == channel_ids[1]) & (
        burst_dictionary["label"] == labels[1]
    )

    # Modulation of scores.
    scores_mod = np.zeros((4, n_comps, len(binned_plot_time) - 1))

    for c, comp in enumerate(comps_to_visualize):
        # Take each component separately.
        metric = drm_comps[:, comp - 1]

        # Take each hand and channel separately.
        for l, cs in enumerate([c3l, c3r, c4l, c4r]):
            mean_measure = []
            for t_idx in range(len(binned_plot_time) - 1):
                # Find the bursts occuring in each time window.
                t_bursts = (
                    (burst_dictionary["peak_time"] >= binned_plot_time[t_idx])
                    & (burst_dictionary["peak_time"] < binned_plot_time[t_idx + 1])
                    & cs
                )

                mean_measure.append(np.mean(metric[t_bursts]) if any(t_bursts) else 0)

            scores_mod[l, c, :] = np.array(mean_measure)

    # Plot.
    for cc in range(4):
        if n_comps == 2:
            ax.plot(
                binned_plot_time[:-1],
                scores_mod[cc, 0, :],
                scores_mod[cc, 1, :],
                c=fig_colors[cc],
                linewidth=linew,
                label=fig_labels[cc],
            )

        elif n_comps == 3:
            ax.scatter(
                scores_mod[cc, 0, :],
                scores_mod[cc, 1, :],
                scores_mod[cc, 2, :],
                c=fig_colors[cc],
                linewidth=linew,
                label=fig_labels[cc],
            )

    # Spines and labels.
    ax.tick_params(axis="x", labelsize=tick_size)
    ax.tick_params(axis="y", labelsize=tick_size)
    ax.tick_params(axis="z", labelsize=tick_size)
    if n_comps == 2:
        ax.set_xlabel("Time (s)", fontsize=label_size)
        ax.set_ylabel(
            "PC {} score (a.u.)".format(comps_to_visualize[0]), fontsize=label_size
        )
        ax.set_zlabel(
            "PC {} score (a.u.)".format(comps_to_visualize[1]), fontsize=label_size
        )
    if n_comps == 3:
        ax.set_xlabel(
            "PC {} score (a.u.)".format(comps_to_visualize[0]), fontsize=label_size
        )
        ax.set_ylabel(
            "PC {} score (a.u.)".format(comps_to_visualize[1]), fontsize=label_size
        )
        ax.set_zlabel(
            "PC {} score (a.u.)".format(comps_to_visualize[2]), fontsize=label_size
        )

    fig.legend(
        frameon=False,
        title="Channel, condition",
        title_fontsize=legend_size,
        fontsize=legend_label_size,
        loc="upper right",
        alignment="left",
    )

    # Optional saving.
    if n_comps == 2:
        figname = join(
            savepath, "average_score_modulation_across_PCs.{}".format(plot_format)
        )
    elif n_comps == 3:
        figname = join(
            savepath, "average_score_modulation_across_PCs_3d.{}".format(plot_format)
        )

    if savefigs == True:
        fig.savefig(figname, dpi=dpi, facecolor="w", edgecolor="w")
    elif savefigs == False:
        plt.show()


def plot_waveforms_score(
    burst_dictionary,
    drm_comps,
    channel_ids,
    solver,
    binned_plot_time,
    base_time_lims,
    mi_end,
    bin_dt,
    tf_method,
    band,
    savepath,
    snapshot_window=None,
    comps_to_visualize=[2, 3, 4],
    brate=False,
    screen_res=[1920, 972],
    dpi=300,
    savefigs=True,
    plot_format="pdf",
):
    """
    Scatter plot of each burst waveform in a dictionary in 2- or 3-dimensional
    dimensionality reduction space. Each waveform is represented by its score
    along the corresponding components.

    Produces a .gif that represents the waveforms' scores in time domain, and
    a standard plot corresponding to a "snapshot" of the .gif.

    Parameters
    ----------
    burst_dictionary: dict
                      Dictionary containing all detected bursts.
    drm_comps: numpy array
               Array containing the transformed bursts as
               returned by the 'fit_transform' method of 'drm'.
    channel_ids: list or str
                 Indices of channels to take into account during burst
                 dictionary creation.
    solver: str, {"pca", "csp"}
            Dimensionality reduction algorithm. Implements the sklearn
            PCA or the MNE-python CSP model.
    binned_plot_time: numpy array
                      Array representing the trimmed experimental time
                      with wide time steps, needed for an estimation
                      of burst rate in non-overlapping windows.
    base_time_lims: two-element list or 1D array
                    Start and end time of the baseline period in seconds,
                    relative to the time-locked event.
    mi_end: int
            End time of the task period in seconds, relative to the
            time-locked event.
    bin_dt: float
            Non-overlapping time window step in seconds.
    tf_method: str {"wavelets", "superlets"}
               String indicating the algorithm used for burst
               extraction. Ignored if 'savefigs' is set to "False".
    band: str {"mu", "beta"}
          Selected band for burst detection.
    savepath: str
              Parent directory that contains all results. Ignored if
              'savefigs' is set to "False".
    snapshot_window: None or two-element list or 1D array, optional
                     Start and end time of the "snapshot" window in seconds,
                     relative to the time-locked event.
                     Defaults to None, which cossresponds to the entire
                     "task period" (base_time_lims[-1], mi_end).
    comps_to_visualize: list, optional
                        List of components used for plotting.
                        Defaults to [2,3,4].
    brate: bool, optional
           If "True", encode burst rate changes relative to baseline
           in marker opacity.
           Defaults to "False".
    screen_res: two-element list, optional
                Number of pixels for specifying the figure size in
                conjunction with "dpi".
                Defaults to [1920, 972].
    dpi: int, optional
         Number of dots per inch for specifying the figure size in
         conjunction with "screen_res".
         Defaults to 300.
    savefigs: bool, optional
              If set to "True" the visualizations are automatically
              saved. If set to "False" they are shown on screen.
              Defaults to "True".
    plot_format: str {"pdf", "png"}, optional
                 File format. Prefer "pdf" for editing with vector graphics
                 applications, or "png" for less space usage and better
                 integration with presentations.
                 Defaults to "pdf".
    """

    # Number of components.
    n_comps = len(comps_to_visualize)
    if n_comps < 2 or n_comps > 3:
        raise ValueError("Number of components for plotting should be 2 or 3.")

    # Figure initialization.
    bag_of_figs = []
    if n_comps == 2:
        savepath_gif = join(savepath, "waveforms_gif")
    elif n_comps == 3:
        savepath_gif = join(savepath, "waveforms_gif_3d")
    if not exists(savepath_gif):
        makedirs(savepath_gif)

    fig0 = plt.figure(constrained_layout=True, figsize=(7, 3), dpi=dpi)

    gs0 = fig0.add_gridspec(1, 1)
    gs00 = gs0[0].subgridspec(1, 1)

    if n_comps == 2:
        ax0 = fig0.add_subplot(gs0[0])
    elif n_comps == 3:
        ax0 = fig0.add_subplot(gs0[0], projection="3d")

    linew = 1.5
    label_size = 6
    tick_size = 6
    legend_size = 6
    legend_label_size = 5

    fig_colors = ["firebrick", "royalblue", "darkorange", "darkorchid"]

    fig_labels = ["C3, left hand", "C3, right hand", "C4, left hand", "C4, right hand"]

    # Channel and condition specific bursts.
    labels = np.unique(burst_dictionary["label"])

    c3l = (burst_dictionary["channel"] == channel_ids[0]) & (
        burst_dictionary["label"] == labels[0]
    )

    c3r = (burst_dictionary["channel"] == channel_ids[0]) & (
        burst_dictionary["label"] == labels[1]
    )

    c4l = (burst_dictionary["channel"] == channel_ids[1]) & (
        burst_dictionary["label"] == labels[0]
    )

    c4r = (burst_dictionary["channel"] == channel_ids[1]) & (
        burst_dictionary["label"] == labels[1]
    )

    # Waveforms' scores for selected components.
    wavefroms_scores = np.zeros((len(burst_dictionary["waveform"]), n_comps))

    for c, comp in enumerate(comps_to_visualize):
        # Take each component separately.
        wavefroms_scores[:, c] = drm_comps[:, comp - 1]

    # Plots 0 - snapshot.
    for cc, cs in enumerate([c3l, c3r, c4l, c4r]):
        # N-d scatter plot of "snapshot window".
        if snapshot_window == None:
            snapshot_bursts = (
                (burst_dictionary["peak_time"] >= base_time_lims[1])
                & (burst_dictionary["peak_time"] < mi_end)
                & cs
            )
        else:
            snapshot_bursts = (
                (burst_dictionary["peak_time"] >= snapshot_window[0])
                & (burst_dictionary["peak_time"] < snapshot_window[1])
                & cs
            )

        if n_comps == 2:
            ax0.scatter(
                wavefroms_scores[snapshot_bursts, 0],
                wavefroms_scores[snapshot_bursts, 1],
                c=fig_colors[cc],
                s=linew,
                label=fig_labels[cc],
            )
        elif n_comps == 3:
            ax0.scatter(
                wavefroms_scores[snapshot_bursts, 0],
                wavefroms_scores[snapshot_bursts, 1],
                wavefroms_scores[snapshot_bursts, 2],
                c=fig_colors[cc],
                s=linew,
                label=fig_labels[cc],
            )

    ax0.tick_params(axis="x", labelsize=tick_size)
    ax0.tick_params(axis="y", labelsize=tick_size)
    ax0.set_xlabel(
        "PC {} score (a.u.)".format(comps_to_visualize[0]), fontsize=label_size
    )
    ax0.set_ylabel(
        "PC {} score (a.u.)".format(comps_to_visualize[1]), fontsize=label_size
    )
    ax0.set_xlim([np.min(wavefroms_scores[:, 0]), np.max(wavefroms_scores[:, 0])])
    ax0.set_ylim([np.min(wavefroms_scores[:, 1]), np.max(wavefroms_scores[:, 1])])
    if n_comps == 2:
        ax0.spines[["top", "right"]].set_visible(False)
    if n_comps == 3:
        ax0.tick_params(axis="z", labelsize=tick_size)
        ax0.set_zlabel(
            "PC {} score (a.u.)".format(comps_to_visualize[2]), fontsize=label_size
        )
        ax0.set_zlim([np.min(wavefroms_scores[:, 2]), np.max(wavefroms_scores[:, 2])])

    fig0.legend(
        frameon=False,
        title="Channel, condition",
        title_fontsize=legend_size,
        fontsize=legend_label_size,
        loc="upper right",
        alignment="left",
    )

    # Optional saving.
    if n_comps == 2:
        figname = join(
            savepath, "{}_band_waveforms_scores.{}".format(band, plot_format)
        )
    elif n_comps == 3:
        figname = join(
            savepath, "{}_band_waveforms_scores_3d.{}".format(band, plot_format)
        )

    if savefigs == True:
        fig0.savefig(figname, dpi=dpi, facecolor="w", edgecolor="w")
    elif savefigs == False:
        plt.show()

    # Plots 1 - waveforms' scores in time.
    for t_idx in range(len(binned_plot_time) - 1):
        # Figure initialization.
        fig1 = plt.figure(constrained_layout=True, figsize=(7, 4.5), dpi=dpi)
        gs1 = fig1.add_gridspec(1, 1)
        gs10 = gs1[0].subgridspec(1, 1)
        if n_comps == 2:
            ax1 = fig1.add_subplot(gs1[0])
        elif n_comps == 3:
            ax1 = fig1.add_subplot(gs1[0], projection="3d")

        bag_of_figs.append(join(savepath_gif, "{}_band_fig_{}.png".format(band, t_idx)))

        for cc, cs in enumerate([c3l, c3r, c4l, c4r]):
            # Optional burst rate estimation.
            if brate == True:
                base_bursts = (
                    (burst_dictionary["peak_time"] >= base_time_lims[0])
                    & (burst_dictionary["peak_time"] < base_time_lims[1])
                    & cs
                )

                base_rate = np.sum(base_bursts) / (
                    len(np.where(binned_plot_time < base_time_lims[1])[0]) * bin_dt
                )

            # Find the bursts occuring in each time window.
            t_bursts = (
                (burst_dictionary["peak_time"] >= binned_plot_time[t_idx])
                & (burst_dictionary["peak_time"] < binned_plot_time[t_idx + 1])
                & cs
            )

            # Potentially encode burst rate in marker transparency.
            if brate == True and binned_plot_time[t_idx] > base_time_lims[1]:
                w_rate = np.sum(t_bursts) / bin_dt
                w_rate = (w_rate - base_rate) / base_rate

                base_alpha = 0.5
                rate_alpha = base_alpha + base_alpha * w_rate
                if rate_alpha > 1:
                    rate_alpha = 1
                elif rate_alpha < 0.05:
                    rate_alpha = 0.05

            elif brate == True and binned_plot_time[t_idx] < base_time_lims[1]:
                rate_alpha = 0.5

            elif brate == False:
                rate_alpha = 1

            if n_comps == 2:
                ax1.scatter(
                    wavefroms_scores[t_bursts, 0],
                    wavefroms_scores[t_bursts, 1],
                    c=fig_colors[cc],
                    s=linew,
                    label=fig_labels[cc],
                    alpha=rate_alpha,
                )
                confidence_ellipse(
                    wavefroms_scores[t_bursts, 0],
                    wavefroms_scores[t_bursts, 1],
                    ax1,
                    n_std=2.0,
                    lw=2.0,
                    edgecolor=fig_colors[cc],
                )
            elif n_comps == 3:
                ax1.scatter(
                    wavefroms_scores[t_bursts, 0],
                    wavefroms_scores[t_bursts, 1],
                    wavefroms_scores[t_bursts, 2],
                    c=fig_colors[cc],
                    s=linew,
                    label=fig_labels[cc],
                    alpha=rate_alpha,
                )

        # Spines and labels.
        ax1.set_title("T = {} s".format(binned_plot_time[t_idx]))
        ax1.tick_params(axis="x", labelsize=tick_size)
        ax1.tick_params(axis="y", labelsize=tick_size)
        ax1.set_xlabel(
            "PC {} score (a.u.)".format(comps_to_visualize[0]), fontsize=label_size
        )
        ax1.set_ylabel(
            "PC {} score (a.u.)".format(comps_to_visualize[1]), fontsize=label_size
        )
        ax1.set_xlim([np.min(wavefroms_scores[:, 0]), np.max(wavefroms_scores[:, 0])])
        ax1.set_ylim([np.min(wavefroms_scores[:, 1]), np.max(wavefroms_scores[:, 1])])
        if n_comps == 2:
            ax1.spines[["top", "right"]].set_visible(False)
        if n_comps == 3:
            ax1.tick_params(axis="z", labelsize=tick_size)
            ax1.set_zlabel(
                "PC {} score (a.u.)".format(comps_to_visualize[2]), fontsize=label_size
            )
            ax1.set_zlim(
                [np.min(wavefroms_scores[:, 2]), np.max(wavefroms_scores[:, 2])]
            )

        fig1.legend(
            frameon=False,
            title="Channel, condition",
            title_fontsize=legend_size,
            fontsize=legend_label_size,
            loc="upper right",
            alignment="left",
        )

        fig1.savefig(bag_of_figs[t_idx])
        plt.close()

    # gif creation.
    if n_comps == 2:
        gif_name = join(savepath, "{}_band_waveforms_scores.gif".format(band))
    elif n_comps == 3:
        gif_name = join(savepath, "{}_band_waveforms_scores_3d.gif".format(band))

    images = []
    for filename in bag_of_figs:
        images.append(imageio.imread(filename))
    imageio.mimwrite(gif_name, images, fps=4)
